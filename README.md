## 네트워크

<details>



<summary><h3> TCP와 UDP의 차이점</h3></summary>


```
// 답변

📌 TCP는 연결 지향형 프로토콜이고, 흐름제어 · 혼잡제어 · 패킷 순서 보장 등을 지원합니다.
신뢰성 향상을 위한 3-way · 4-way handshake 과정이 있어 UDP 보다는 속도가 느립니다.

📌 UDP는 비연결형 프로토콜입니다.
데이터의 수신 여부를 확인하지 않고 패킷의 순서 보장을 하지 않기 때문에 신뢰성이 낮지만 속도가 빠르다는 장점이 있습니다.
```



### 📖 **TMI**

<div align = "center">
  <img src="https://raw.githubusercontent.com/buinq/imageServer/main/img/image-20230623154540657.png" alt="image-20230623154540657" style="width: 500px;"  />
</div>


TCP와 UDP는 OSI 7 계층 중 **전송 계층에 해당하는 프로토콜**이다.

전송 계층은 신뢰성있는 데이터 전송을 담당하는 계층이다.

<br>

1️⃣ **TCP (Transmission Control Protocol)**

TCP의 전송 단위는 세그먼트라고 하며, 각 세그먼트는 헤더를 갖는다.

IP가 컴퓨터 레벨까지의 데이터의 전송을 처리한다면, TCP는 응용 프로그램으로의 패킷 관리와 추적을 당담한다.

<div align = "center">
<img src="https://raw.githubusercontent.com/buinq/imageServer/main/img/image-20230623152421689.png" alt="image-20230623152421689" style="width: 500px;" />
</div>


헤더의 목적지 포트 주소를 지정해 전송한다. 예를 들어, 웹으로 접근하는 목적지 포트는 80이다.

`Sequence number` 헤더는 TCP 세그먼트의 순서번호를 표시하고 이를 통해 전송하는 패킷의 순서를 보장할 수 있다.

그리고 `CheckSum` 정보를 통해 데이터 오류가 발생했는지 검사한다.

> CheckSum은 간단히 말하면, 데이터를 더해서 만든 바이트를 이용해서, `체크섬 바이트 + (데이터 총 합 바이트) = 0` 을 만족하는 체크섬 바이트라는 것을 얻고, 데이터 전송 후에도 체크섬 바이트를 더했을 때 0이 나오는지 확인하는 것이다.

`Flags` 에는 `ACK` · `SYN` · `FIN` 과 같은 플래그 비트들이 있고 이를 통해서 연결 과정에선 3-way handShake 혹은 연결 해제 과정에 4-way handShake를 진행한다.

<br>

💡 데이터 송신 측과 수신 측의 처리 속도를 조절하여 흐름 조절을 하고 네트워크 내의 패킷 수를 조절하여 혼잡 제어를 수행한다.



🚨 단, 신뢰성을 중요시하다보니, 매번 handShake 같은 과정이 수반되므로 시간 손실이 발생하고 패킷의 전송 순서에 맞게 수신이 안되거나 손실되는 경우 재 전송함으로서 시간 손실이 발생한다는 단점이 있다. 그리고 1대1 통신만 가능하다.

<br>

2️⃣ **UDP (User Datagram Protocol)**

<div align = "center">
<img src="https://raw.githubusercontent.com/buinq/imageServer/main/img/image-20230623152255679.png" alt="image-20230623152255679"  style="width: 500px;" />
</div>


UDP도 TCP와 동일하게 포트번호를 지정하고 `CheckSum` 이 존재한다.

UDP는 신뢰성 연결보다는 빠른 전송에 중점을 둔 프로토콜이다.

따라서, 🚨 데이터의 수신 여부나 전송한 패킷 순서대로 수신되었는지 확인하지 않는다.

💡 속도가 빠르다는 이점이 있어 실시간 스트리밍, DNS(Domain Name System) 등 데이터의 신속한 전송이 중요한 비대화형 애플리케이션에 적합하다.

데이터의 순서나 신뢰성이 크게 중요하지 않고 TCP의 연결 설정과 재전송 기능이 실시간 요구사항을 충족하지 못할 수 있기 때문이다.

</details>



<br>



## 운영체제

<details>



<summary><h3> 프로세스와 스레드의 차이</h3></summary>


```
// 답변
프로세스란 운영체제로부터 시스템 자원을 할당받아 메모리에서 실행되는 작업 단위입니다.
스레드는 프로세스가 할당받은 자원을 이용하는 작업 단위입니다. 즉, 프로세스는 최소 1개의 스레드를 갖고 있습니다.
```



### 📖 **TMI**



1️⃣ **프로세스**

<div align = "center">
    <img src="https://raw.githubusercontent.com/WeareSoft/tech-interview/master/contents/images/process.png" alt="img"  style="width: 500px;" />
</div>



프로세스는 💡 **메모리에 올라와 실행되고 있는 프로그램이며 하나의 작업 단위**이다.

프로그램을 실행하기 위해서, 운영체제는 프로그램을 메모리의 적당한 위치로 가져온다.

그와 동시에 프로세스를 처리하기 위한 도구인 PCB(Process Control Block) 를 생성한다.

<br>

PCB에는 프로세스 구분자, 프로세스의 메모리 상 위치 등 프로세스를 처리하기 위한 정보가 있다.

프로세스가 종료될 때, PCB도 함께 제거된다.

참고로, CPU를 차지하던 프로세스를 교체하는 과정에서 사용하던 PCB를 내보내고 새로운 PCB를 받아들이는 과정을 문맥교환이라고 한다.

<br>

<div align = "center">
    <img src="https://raw.githubusercontent.com/buinq/imageServer/main/img/image-20230626184113665.png" alt="image-20230626184113665"  style="width: 700px;"/>
</div>

프로세스는 위와 같이 5개의 상태로 구분된다.

1. 생성 상태 : 프로세스가 메모리에 올라와 실행 준비를 완료한 상태, 프로세스를 처리하기 위한 PCB를 생성한다.
2. 준비 상태 : 생성된 프로세스가 CPU(자원)을 얻기 위해 기다리는 상태이다. CPU가 1개라면, 한 번에 하나의 프로세스만 실행할 수 있기 때문이다.
3. 실행 상태 : 프로세스가 CPU(자원)을 얻어 작업을 수행 중인 상태이다. CPU 스케줄러에 의해 선택된 프로세스는 일정 시간 CPU를 사용할 권리를 갖는다.
4. 완료 상태 : 주어진 시간 동안 작업을 다 마치면 완료 상태가 되고 PCB가 제거된다.
5. 대기 상태 : 입출력을 요구한 프로세스가 입출력이 완료될 때까지 기다리는 상태이다. CPU가 입출력까지 관여하면 효율이 떨어지기 때문에 입출력 관리자를 통해서 입출력 작업을 요청하면, 입출력 관리자는 입출력이 완료되었을 때 인터럽트라는 신호를 CPU에게 보내 완료됐음을 알린다. 대기 상태의 프로세스가 입출력이 완료되면 준비 상태로 들어가 자신의 차례를 기다리게 된다.

<br>

2️⃣ **스레드**

스레드는 💡 **프로세스가 할당받은 자원을 이용하는 실행 단위**이다.

<div align = "center">
    <img src="https://github.com/WeareSoft/tech-interview/raw/master/contents/images/thread.png" alt="img" style="width: 500px;"/>
</div>

하나의 프로세스에는 최소 하나의 스레드(실행 단위)가 존재한다.

스레드가 여러개인 경우, 스레드들 간에 프로세스의 자원인 Code, Data, Heap 영역은 공유하고 각 스레드는 별도의 stack을 갖는다.

스레드를 여러개 사용하면 프로세스가 처리해야 할 작업을 분담할 수 있어 작업 부담을 줄일 수 있지만, 하나의 스레드에 문제가 생기면 프로세스가 종료된다.

</details>



## 

<details>



<summary><h3> 멀티 스레드와 멀티 프로세스의 특징</h3></summary>


```
// 답변
멀티 프로세스는 하나의 프로세스의 문제가 다른 프로세스에 영향을 주지 않지만, 자원을 많이 사용하고 문맥 교환으로 인한 성능저하가 발생합니다.

멀티 스레드는 스레드간 프로세스의 자원을 공유해서 메모리를 아낄 수 있고 문맥 교환이 빠르다는 장점이 있지만 
동기화 문제로 인한 성능 저하와 하나의 스레드 문제가 해당 프로세스의 모든 스레드에 영향을 준다는 단점이 있습니다.
```



### 📖 **TMI**



1️⃣ **멀티 프로세스**

멀티 프로세스는 단어 그대로, 여러개의 프로세스를 사용해 작업을 병렬처리하는 것이다.



💡 멀티 프로세스는 서로 독립적인 메모리 공간을 갖기 때문에, 문제가 생겨도 서로에게 영향을 주지 않는다.

다만, 🚨 서로의 메모리 영역에 직접 접근할 수 없어 정보를 주고 받아야 하는 경우 IPC 통신을 사용해야하는데 비효율적이고 복잡하다.

그리고 CPU의 자원을 사용하는 프로세스를 교체하는 문맥 교환 과정이 빈번하게 일어나기 때문에 성능 저하가 발생할 수 있다.



2️⃣ **멀티 스레드**

프로세스가 작업을 처리하는데 사용하는 작업 단위를 스레드라고 하고, 이러한 스레드가 여러 개 있다는 의미이다.

여러 개의 스레드가 동시에 작업을 처리할 수 있기 때문에 단일 스레드보다 효율적으로 작업을 처리할 수 있다.

<br>

그리고 💡 프로세스 내의 Code, Data, Heap 메모리를 공유하기 때문에 스레드 간 효율적으로 통신할 수 있고 

스레드 간 문맥 교환이 프로세스간 문맥 교환보다 빨라 작업 처리 시간을 단축시킬 수 있다.

다만, 🚨 한 스레드에서 발생한 문제가 다른 스레드에 영향을 줄 수 있고 공유 자원의 동기화 작업 때문에 병목 현상이나 데드락이 발생할 수 있다.



<br>

📌 인터넷 익스플로러의 탭 기능은 멀티 스레드이고 크롬의 탭 기능은 멀티 프로세스이다.

크롬 탭은 멀티 프로세스이기 때문에, 탭 마다 메모리를 할당받아 메모리를 많이 점유할 수 있지만 하나의 탭에 문제가 생겨 다른 탭도 종료가 되는 상황을 방지할 수 있다.

익스플로러의 경우 싱글 프로세스에 멀티 스레드 방식으 하나의 탭에 문제가 생기면 다른 탭에도 영향을 준다.



</details>





<br>



## 데이터베이스

<details>



<summary><h3> 트랜잭션의 ACID 속성이란?</h3></summary>


```
// 답변
트랜잭션은 데이터베이스의 상태를 변화시키는 논리적인 작업 단위입니다.

ACID는 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질로 4가지 특성이 있습니다.
 
 1. 원자성(Atomicity) 
    트랜잭션이 DB에 모두 반영되거나, 중간에 어떤 문제가 발생한다면 전혀 반영되지 않아야 합니다.
    
 2. 일관성(consistency)
    트랜잭션 작업이 완료된 후에도, 데이터베이스의 제약조건이 지켜져야 합니다.
    
 3. 고립성(Isolation)
    둘 이상의 트랜잭션이 실행되고 있을 때, 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 합니다.
    
 4. 지속성(Durability)
    성공적으로 트랜잭션이 수행되었다면, 그 결과는 데이터베이스에 보존되어야 합니다.
```



### 📖 **TMI**



</details>









<br>

## 

<details>



<summary><h3> 질문</h3></summary>


```
// 답변

```



### 📖 **TMI**



</details>





